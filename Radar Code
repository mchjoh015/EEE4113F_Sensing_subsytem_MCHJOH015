import processing.net.*;
import java.util.ArrayList;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

PFont radarFont;

int angle = 0, distance = 0;
boolean calibrating = true;
int calibrationTime = 20000;
int startTime;
ArrayList<PVector> knownObjects = new ArrayList<PVector>();

// UDP setup
DatagramSocket socket;
byte[] buffer = new byte[1024];

void setup() {
  size(1400, 800);
  radarFont = createFont("Arial", 24, true);
  startTime = millis();

  try {
    socket = new DatagramSocket(4210); // Must match udpPort on ESP32
    socket.setSoTimeout(1); // Prevent blocking
    println("UDP socket ready.");
  } catch (Exception e) {
    println("Failed to open UDP socket: " + e.getMessage());
  }
}

void draw() {
  background(0);

  // Receive and parse UDP data
  receiveUDP();

  drawRadar();
  drawDetectionLine();
  if (calibrating) {
    calibrateObjects();
  } else {
    drawObject();
  }
  drawKnownObjects();
  drawText();

  if (calibrating && millis() - startTime > calibrationTime) {
    calibrating = false;
    println("Calibration complete. Normal operation started.");
  }
}

void receiveUDP() {
  try {
    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
    socket.receive(packet);
    String message = new String(packet.getData(), 0, packet.getLength()).trim();

    // Parse angle and distance
    if (message.contains(",")) {
      String[] parts = message.split(",");
      if (parts.length == 2) {
        angle = int(parts[0]);
        distance = int(trim(parts[1].replace(".", ""))); // Remove any trailing "."
      }
    }
  } catch (Exception e) {
    // Do nothing (timeout likely)
  }
}

void drawRadar() {
  pushMatrix();
  translate(width / 2, height - 100);
  stroke(98, 245, 31);
  strokeWeight(3);
  noFill();
  float maxRadius = 500;
  for (int i = 1; i <= 4; i++) ellipse(0, 0, i * maxRadius / 2, i * maxRadius / 2);
  for (int i = 0; i <= 180; i += 30) line(0, 0, maxRadius * cos(radians(i)), -maxRadius * sin(radians(i)));
  popMatrix();
}

void calibrateObjects() {
  if (distance <= 100) {
    float pixDist = map(distance, 0, 100, 0, 500);
    float x = pixDist * cos(radians(angle));
    float y = -pixDist * sin(radians(angle));
    boolean alreadyStored = false;
    for (PVector obj : knownObjects) {
      if (dist(x, y, obj.x, obj.y) < 20) {
        alreadyStored = true;
        break;
      }
    }
    if (!alreadyStored) knownObjects.add(new PVector(x, y));
  }
}

void drawObject() {
  pushMatrix();
  translate(width / 2, height - 100);
  if (distance <= 100) {
    float pixDist = map(distance, 0, 100, 0, 500);
    float x = pixDist * cos(radians(angle));
    float y = -pixDist * sin(radians(angle));
    boolean known = false;
    for (PVector obj : knownObjects) {
      if (dist(x, y, obj.x, obj.y) < 20) {
        known = true;
        break;
      }
    }
    if (!known) {
      stroke(255, 10, 10);
      strokeWeight(8);
      line(x - 10, y - 10, x + 10, y + 10);
      line(x - 10, y + 10, x + 10, y - 10);
    }
  }
  popMatrix();
}

void drawKnownObjects() {
  pushMatrix();
  translate(width / 2, height - 100);
  for (PVector obj : knownObjects) {
    noStroke();
    fill(0, 255, 0, 50);
    ellipse(obj.x, obj.y, 20, 20);
    fill(0, 255, 0, 200);
    ellipse(obj.x, obj.y, 8, 8);
  }
  popMatrix();
}

void drawDetectionLine() {
  pushMatrix();
  translate(width / 2, height - 100);
  stroke(30, 250, 60);
  strokeWeight(6);
  line(0, 0, 500 * cos(radians(angle)), -500 * sin(radians(angle)));
  popMatrix();
}

void drawText() {
  fill(98, 245, 31);
  textFont(radarFont);
  textSize(28);
  if (calibrating) text("CALIBRATING... (" + (20 - (millis() - startTime)/1000) + "s left)", 50, height - 100);
  text("Angle: " + angle + "Â°", 50, height - 50);
  if (distance <= 100) text("Distance: " + distance + " cm", 250, height - 50);
  else text("Distance: Out of Range", 250, height - 50);
}
